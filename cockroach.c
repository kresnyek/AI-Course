#pragma config(Sensor, S1,     Sound,          sensorSoundDBA)
#pragma config(Sensor, S3,     frontDistanceSensor, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     lightSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Motor,  motorA,          rMotor,        tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          uMotor,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          lMotor,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Globals

//how fast the usual speed is for forward
int runningSpeed = 50;
int ambientLight;
int currentLDirection = 0;
int currentNext = 0;
int currentLight;

bool reverseUmotorFlag = false;
/*--------------------------------------------
Directions: All relative from lightSensor

               \   0   /
           -1   \     /      1
     -2         |Sensor|          2
----------------------------------------------*/

//Flags-------------------------------------------------------------------------------------

//This is used to not run the robot forward if it needs to turn or something is in the way.
bool stopMotorsFlag = false;

//This is used to tell if something is in the way of the sonar sensor
bool obstructionFlag = false;

//This determines if a new path is found
bool darkerPathFlag = false;

bool turnFlag = false;

bool iAmHappy = false;


//Actions

//Next Direction to travel
int nextDirection = 0;


task findDarkness()
{
	while(true)
	{
	darkerPathFlag = false;

	if((currentLight >= SensorValue(lightSensor)) && (currentLight > 0.2*ambientLight) && (currentLight > 1))
	{
		displayBigTextLine(13, "I AM NOT HAPPY");
		currentLight = SensorValue(lightSensor);
		stopMotorsFlag = false;
		iAmHappy = false;
	}

	else if ((SensorValue(lightSensor) > 1.2*ambientLight) && (currentLight > 0.9*ambientLight) && (currentLight > 1))
	{
		displayBigTextLine(13, "I AM NOT HAPPY");
		iAmHappy = false;
		darkerPathFlag = true;
		if(turnFlag)
		{
			nextDirection = 2;
			stopMotorsFlag = true;

		}
		else
		{
			nextDirection = -2;
			stopMotorsFlag = true;

		}
	}
	else
	{
		iAmHappy = true;
		playSound(soundBlip);
		displayBigTextLine(13, "I AM HAPPY");
		stopMotorsFlag = true;
		currentLight = SensorValue(lightSensor);
	}

	turnFlag = !turnFlag;
	releaseCPU();
}
	/*darkerPathFlag = false;
	stopMotorsFlag = false;
	while(true)
	{
		setMotorReversed(uMotor, reverseUmotorFlag);
		moveMotorTarget(uMotor, 45, 100);

		//change to relative, not abolsute

		if((SensorValue(lightSensor) < currentDarkest) && (currentLightest > 1))
		{
			currentDarkest = SensorValue(lightSensor);
		}

		if(reverseUmotorFlag)
		{
			currentDirection++;
		}

		else
		{
			currentDirection--;
		}

		if(direction == 1 || direction == -1)
		{
			reverseUmotorFlag = !reverseUmotorFlag;
		}
	}*/

	/*darkerPathFlag = false;
	stopMotorsFlag = false;
	int currentDarkest = SensorValue(lightSensor);
	int currentLightest = SensorValue(lightSensor);
	nextDirection = 0;
	int value;

	while(true)
	{
			hogCPU();
			setMotorReversed(uMotor, true);
			moveMotorTarget(UMotor, 90, 50);
			sleep(300);

			setMotorReversed(uMotor, false);
			value = SensorValue(lightSensor);
			moveMotorTarget(uMotor, 90, 50);
			sleep(300);
			releaseCPU();

			if(value < currentDarkest)
			{
				///playSound(soundBeepBeep);
				currentDarkest = value;
				stopMotorsFlag = true; // stop motors to turn
				darkerPathFlag = true; //new direction to go
				nextDirection = -1;
			}

	}*/

}

task distanceTask()
{
	while(true)
	{
		if(sensorValue(frontDistanceSensor)< 30)
		{
			obstructionFlag = true;
			stopMotorsFlag = true;

		}
		else
		{
			obstructionFlag = false;
			if(iAmHappy)
			{
				stopMotorsFlag = false;
			}
		}
		releaseCPU();
	}
}

//Motion Tasks -------------------------------------------
//Continually moves straight
task moveStraight()
{
	while(true)
	{
	if(!stopMotorsFlag)
	{
		setMotorSyncTime(rMotor, lMotor, 0, 500, runningSpeed);
	}
}
	releaseCPU();
}

//turns 90 degrees
task left90()
{
	hogCPU();
	setMotorSyncTime(rMotor, lMotor, 100, 1000, 100);
	sleep(1000);
	releaseCPU();
}

task left45()
{
	hogCPU();
	setMotorSyncTime(rMotor, lMotor, 100, 500, 55);
	sleep(500);
	releaseCPU();
}

task right90()
{
	hogCPU();
		setMotorSyncTime(rMotor, lMotor, -100, 1000, 55);
		sleep(1000);
		releaseCPU();
}

task right45()
{
	hogCPU();
	setMotorSyncTime(rMotor, lMotor, -100, 500, 55);
	sleep(500);
	releaseCPU();
}

task main()
{
	//set default
	ambientLight = sensorValue(lightSensor);
	currentLight = sensorValue(lightSensor);

	while(true)
	{
		hogCPU();
		startTask(findDarkness);
		startTask(distanceTask);

		if(!stopMotorsFlag && !iAmHappy)
		{
			startTask(moveStraight);
		}

		if(obstructionFlag && !iAmHappy)
		{
			if(turnFlag)
			{
				stopMotorsFlag = true;
				startTask(right90);
				sleep(500);
			}
			else
			{
				stopMotorsFlag = true;
				startTask(left90);
				sleep(500);
			}

		}

		if(darkerPathFlag)
		{
			switch(nextDirection)
			{
				case 2:
					startTask(right90);
					sleep(500);
					break;

				case -2:
					startTask(left90);
					sleep(500);
					break;
			}
		}

			displayBigTextLine(1, "Distance: %d",SensorValue(frontDistanceSensor));
			displayBigTextLine(4, "currentL: %d", currentLight);
			displayBigTextLine(7, "Sensorv: %d",SensorValue(lightSensor));
			displayBigTextLine(10, "Ambient: %d",ambientLight);
		sleep(500);
		stopTask(findDarkness);
		stopTask(distanceTask);
		stopTask(moveStraight);
		releaseCPU();
	}


}
